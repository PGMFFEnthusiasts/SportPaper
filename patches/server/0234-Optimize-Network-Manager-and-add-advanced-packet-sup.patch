From cf71ce3260c8eb94843e6892477b9add50a10ea5 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 6 May 2020 04:53:35 -0400
Subject: [PATCH] Optimize Network Manager and add advanced packet support

Adds ability for 1 packet to bundle other packets to follow it
Adds ability for a packet to delay sending more packets until a state is ready.

Removes synchronization from sending packets
Removes processing packet queue off of main thread
  - for the few cases where it is allowed, order is not necessary nor
    should it even be happening concurrently in first place (handshaking/login/status)

Ensures packets sent asynchronously are dispatched on main thread

This helps ensure safety for ProtocolLib as packet listeners
are commonly accessing world state. This will allow you to schedule
a packet to be sent async, but itll be dispatched sync for packet
listeners to process.

This should solve some deadlock risks

Also adds Netty Channel Flush Consolidation to reduce the amount of flushing

Also avoids spamming closed channel exception by rechecking closed state in dispatch
and then catch exceptions and close if they fire.

Part of this commit was authored by: Spottedleaf, sandtechnology

diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 0c2aab10e..bdc5eb6b2 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -62,6 +62,11 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     };
     private final EnumProtocolDirection h;
     private final Queue<NetworkManager.QueuedPacket> i = Queues.newConcurrentLinkedQueue();
+    // SportPaper start - OBFHELPER
+    private Queue<NetworkManager.QueuedPacket> getQueuedPackets() {
+        return this.i;
+    }
+    // SportPaper end
     private final ReentrantReadWriteLock j = new ReentrantReadWriteLock();
     public Channel channel;
     // Spigot Start // PAIL
@@ -76,6 +81,10 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     private boolean p;
     public int protocolVersion; // Paper
     private static final boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush"); // Paper
+    // Paper start - Optimize network
+    public boolean isPending = true;
+    public EnumProtocol protocol;
+    // Paper end - Optimize network
 
     public NetworkManager(EnumProtocolDirection enumprotocoldirection) {
         this.h = enumprotocoldirection;
@@ -98,6 +107,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
 
     public void a(EnumProtocol enumprotocol) {
+        this.protocol = enumprotocol; // Paper - Optimize network
         this.channel.attr(NetworkManager.c).set(enumprotocol);
         this.channel.config().setAutoRead(true);
         NetworkManager.g.debug("Enabled auto read");
@@ -138,35 +148,49 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
 
     public void handle(Packet packet) {
-        if (this.g()) {
-            this.m();
-            this.a(packet, (GenericFutureListener[]) null);
-        } else {
-            this.j.writeLock().lock();
+        // Paper - Optimize network
+        this.a(packet, null);
+    }
 
-            try {
-                this.i.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) null));
-            } finally {
-                this.j.writeLock().unlock();
-            }
+    public void a(Packet packet, GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, GenericFutureListener<? extends Future<? super Void>>... agenericfuturelistener) {
+        // Paper start - Optimize network: Handle oversized packets better
+        GenericFutureListener<? extends Future<? super Void>>[] listeners = null;
+        if (genericfuturelistener != null || agenericfuturelistener != null) { // cannot call ArrayUtils.add with both null arguments
+            listeners = ArrayUtils.insert(0, agenericfuturelistener, genericfuturelistener);
         }
 
-    }
+        final boolean connected = this.isConnected();
+        if (!connected && !this.preparing) {
+            return;
+        }
 
-    public void a(Packet packet, GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, GenericFutureListener<? extends Future<? super Void>>... agenericfuturelistener) {
-        if (this.g()) {
-            this.m();
-            this.a(packet, (GenericFutureListener[]) ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener));
+        packet.onPacketDispatch(this.getPlayer());
+        if (connected && (InnerUtil.canSendImmediate(this, packet)
+            || (MinecraftServer.getServer().isMainThread() && packet.isReady() && this.getQueuedPackets().isEmpty()
+            && (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())))) {
+            this.a(packet, listeners);
         } else {
-            this.j.writeLock().lock();
+            // Write the packets to the queue, then flush - antixray hooks there already
+            final java.util.List<Packet<?>> extraPackets = InnerUtil.buildExtraPackets(packet);
+            final boolean hasExtraPackets = extraPackets != null && !extraPackets.isEmpty();
+            if (!hasExtraPackets) {
+                this.getQueuedPackets().add(new NetworkManager.QueuedPacket(packet, listeners));
+            } else {
+                final java.util.List<QueuedPacket> actions = new java.util.ArrayList<>(1 + extraPackets.size());
+                actions.add(new QueuedPacket(packet, (GenericFutureListener<? extends Future<? super Void>>) null)); // Delay the future listener until the end of the extra packets
 
-            try {
-                this.i.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener)));
-            } finally {
-                this.j.writeLock().unlock();
+                for (int i = 0, len = extraPackets.size(); i < len;) {
+                    final Packet<?> extraPacket = extraPackets.get(i);
+                    final boolean end = ++i == len;
+                    actions.add(new QueuedPacket(extraPacket, end ? listeners : null)); // Append listener to the end
+                }
+
+                this.getQueuedPackets().addAll(actions);
             }
-        }
 
+            this.m();
+        }
+        // Paper end - Optimize network
     }
 
     private void a(final Packet packet, final GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) {
@@ -179,53 +203,102 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         }
 
         if (this.channel.eventLoop().inEventLoop()) {
-            if (enumprotocol != enumprotocol1) {
-                this.a(enumprotocol);
-            }
+            doSendPacket(packet, enumprotocol, enumprotocol1, agenericfuturelistener);
+        } else {
+            this.channel.eventLoop().execute(() -> doSendPacket(packet, enumprotocol, enumprotocol1, agenericfuturelistener));
+        }
+
+    }
+
+    // SportPaper start - move common code to helper method
+    private void doSendPacket(Packet<?> packet, EnumProtocol enumprotocol, EnumProtocol enumprotocol1, GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) {
+        if (enumprotocol != enumprotocol1) {
+            this.a(enumprotocol);
+        }
 
+        // Paper start - Optimize network
+        EntityPlayer player = getPlayer();
+        if (!this.isConnected()) {
+            packet.onPacketDispatchFinish(player, null);
+            return;
+        }
+
+        try {
+        // Paper end - Optimize network
             ChannelFuture channelfuture = this.channel.writeAndFlush(packet);
 
             if (agenericfuturelistener != null) {
                 channelfuture.addListeners(agenericfuturelistener);
             }
 
-            channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
-        } else {
-            this.channel.eventLoop().execute(new Runnable() {
-                public void run() {
-                    if (enumprotocol != enumprotocol1) {
-                        NetworkManager.this.a(enumprotocol);
-                    }
+            // Paper start - Optimize network
+            if (packet.hasFinishListener()) {
+                channelfuture.addListener((ChannelFutureListener) channelFuture -> packet.onPacketDispatchFinish(player, channelFuture));
+            }
+            // Paper end - Optimize network
 
-                    ChannelFuture channelfuture = NetworkManager.this.channel.writeAndFlush(packet);
+            channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+        // Paper start - Optimize network
+        } catch (Exception e) {
+            g.error("NetworkException: " + player, e);
+            close(new ChatMessage("disconnect.genericReason", "Internal Exception: " + e.getMessage()));
+            packet.onPacketDispatchFinish(player, null);
+        }
+        // Paper end - Optimize network
+    }
+    // SportPaper end
 
-                    if (agenericfuturelistener != null) {
-                        channelfuture.addListeners(agenericfuturelistener);
-                    }
+    // Paper start - Optimize network: Rewrite this to be safer if ran off main thread
+    private boolean m() {
+        if (!this.isConnected()) {
+            return true;
+        }
 
-                    channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
-                }
-            });
+        if (MinecraftServer.getServer().isMainThread()) {
+            return this.processQueue();
+        } else if (this.isPending) {
+            // Should only happen during login/status stages
+            synchronized (this.getQueuedPackets()) {
+                return this.processQueue();
+            }
         }
 
+        return false;
     }
 
-    private void m() {
-        if (this.channel != null && this.channel.isOpen()) {
-            this.j.readLock().lock();
+    private boolean processQueue() {
+        if (this.getQueuedPackets().isEmpty()) {
+            return true;
+        }
 
-            try {
-                while (!this.i.isEmpty()) {
-                    NetworkManager.QueuedPacket networkmanager_queuedpacket = (NetworkManager.QueuedPacket) this.i.poll();
+        // If we are on main, we are safe here in that nothing else should be processing queue off main anymore
+        // But if we are not on main due to login/status, the parent is synchronized on packetQueue
+        final java.util.Iterator<QueuedPacket> iterator = this.getQueuedPackets().iterator();
+        while (iterator.hasNext()) {
+            final QueuedPacket queued = iterator.next(); // poll -> peek
 
-                    this.a(networkmanager_queuedpacket.a, networkmanager_queuedpacket.b);
-                }
-            } finally {
-                this.j.readLock().unlock();
+            // Fix NPE (Spigot bug caused by handleDisconnection())
+            if (queued == null) {
+                return true;
+            }
+
+            if (queued.isConsumed()) {
+                continue;
+            }
+
+            final Packet<?> packet = queued.getPacket();
+            if (!packet.isReady()) {
+                return false;
             }
 
+            iterator.remove();
+            if (queued.tryMarkConsumed()) {
+                this.a(packet, queued.getListener());
+            }
         }
+        return true;
     }
+    // Paper end - Optimize network
 
     public void a() {
         this.m();
@@ -241,9 +314,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
 
     public void close(IChatBaseComponent ichatbasecomponent) {
-        // Spigot Start
-        this.preparing = false;
-        // Spigot End
+        this.preparing = false; // Spigot
+        this.clearPacketQueue(); // Paper - Optimize network
         if (this.channel.isOpen()) {
             this.channel.close(); // We can't wait as this may be called from an event loop.
             this.n = ichatbasecomponent;
@@ -261,6 +333,10 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         this.channel.pipeline().addBefore("prepender", "encrypt", new PacketEncrypter(MinecraftEncryption.a(1, secretkey)));
     }
 
+    public boolean isConnected() { // SportPaper - OBFHELPER
+        return this.g();
+    }
+
     public boolean g() {
         return this.channel != null && this.channel.isOpen();
     }
@@ -315,9 +391,9 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
                 } else if (this.getPacketListener() != null) {
                     this.getPacketListener().a(new ChatComponentText("Disconnected"));
                 }
-                this.i.clear(); // Free up packet queue.
+                this.clearPacketQueue(); // Paper - Optimize network
             } else {
-                NetworkManager.g.warn("handleDisconnection() called twice");
+                // NetworkManager.g.warn("handleDisconnection() called twice"); // Paper - Don't log useless message
             }
 
         }
@@ -332,6 +408,28 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         private final Packet a;
         private final GenericFutureListener<? extends Future<? super Void>>[] b;
 
+        // SportPaper start - OBFHELPER
+        public Packet<?> getPacket() {
+            return a;
+        }
+
+        public GenericFutureListener<? extends Future<? super Void>>[] getListener() {
+            return b;
+        }
+        // SportPaper end
+
+        // Paper start - isConsumed flag for the connection
+        private final java.util.concurrent.atomic.AtomicBoolean isConsumed = new java.util.concurrent.atomic.AtomicBoolean(false);
+
+        public boolean tryMarkConsumed() {
+            return isConsumed.compareAndSet(false, true);
+        }
+
+        public boolean isConsumed() {
+            return isConsumed.get();
+        }
+        // Paper end - isConsumed flag for the connection
+
         public QueuedPacket(Packet packet, GenericFutureListener<? extends Future<? super Void>>... agenericfuturelistener) {
             this.a = packet;
             this.b = agenericfuturelistener;
@@ -344,4 +442,56 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         return this.channel.remoteAddress();
     }
     // Spigot End
+
+    // Paper start - Optimize network
+    public void clearPacketQueue() {
+        EntityPlayer player = getPlayer();
+        for (final QueuedPacket queued : this.getQueuedPackets()) {
+            final Packet<?> packet = queued.getPacket();
+            if (packet.hasFinishListener()) {
+                packet.onPacketDispatchFinish(player, null);
+            }
+        }
+        this.getQueuedPackets().clear();
+    }
+
+    public EntityPlayer getPlayer() {
+        if (m instanceof PlayerConnection) {
+            return ((PlayerConnection) m).player;
+        } else {
+            return null;
+        }
+    }
+
+    private static class InnerUtil { // Attempt to hide these methods from ProtocolLib, so it doesn't accidentally pick them up.
+        private static java.util.List<Packet<?>> buildExtraPackets(final Packet<?> packet) {
+            final java.util.List<Packet<?>> extra = packet.getExtraPackets();
+            if (extra == null || extra.isEmpty()) {
+                return null;
+            }
+
+            final java.util.List<Packet<?>> ret = new java.util.ArrayList<>(1 + extra.size());
+            buildExtraPackets0(extra, ret);
+            return ret;
+        }
+
+        private static void buildExtraPackets0(final java.util.List<Packet<?>> extraPackets, final java.util.List<Packet<?>> into) {
+            for (final Packet<?> extra : extraPackets) {
+                into.add(extra);
+                final java.util.List<Packet<?>> extraExtra = extra.getExtraPackets();
+                if (extraExtra != null && !extraExtra.isEmpty()) {
+                    buildExtraPackets0(extraExtra, into);
+                }
+            }
+        }
+
+        private static boolean canSendImmediate(final NetworkManager networkManager, final Packet<?> packet) {
+            return networkManager.isPending || networkManager.protocol != EnumProtocol.PLAY ||
+                packet instanceof PacketPlayOutKeepAlive ||
+                packet instanceof PacketPlayOutChat ||
+                packet instanceof PacketPlayOutTabComplete ||
+                packet instanceof PacketPlayOutTitle;
+        }
+    }
+    // Paper end - Optimize network
 }
diff --git a/src/main/java/net/minecraft/server/Packet.java b/src/main/java/net/minecraft/server/Packet.java
index fdc142b75..c2fd6de0d 100644
--- a/src/main/java/net/minecraft/server/Packet.java
+++ b/src/main/java/net/minecraft/server/Packet.java
@@ -9,4 +9,31 @@ public interface Packet<T extends PacketListener> {
     void b(PacketDataSerializer packetdataserializer) throws IOException;
 
     void a(T t0);
+
+    // Paper start
+    /**
+     * @param player {@code null} if not at {@link EnumProtocol#PLAY} stage yet.
+     */
+    default void onPacketDispatch(EntityPlayer player) {
+    }
+
+    /**
+     * @param player {@code null} if not at {@link EnumProtocol#PLAY} stage yet.
+     * @param future Can be {@code null} if packet was cancelled.
+     */
+    default void onPacketDispatchFinish(EntityPlayer player, io.netty.channel.ChannelFuture future) {
+    }
+
+    default boolean hasFinishListener() {
+        return false;
+    }
+
+    default boolean isReady() {
+        return true;
+    }
+
+    default java.util.List<Packet<?>> getExtraPackets() {
+        return null;
+    }
+    // Paper end
 }
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
index e64c8c4c3..e4566014a 100644
--- a/src/main/java/net/minecraft/server/ServerConnection.java
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -64,10 +64,12 @@ public class ServerConnection {
     private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
     // Paper start - prevent blocking on adding a new connection while the server is ticking
     private final java.util.Queue<NetworkManager> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    private static final boolean disableFlushConsolidation = Boolean.getBoolean("Paper.disableFlushConsolidate"); // Paper
     private void addPending() {
         NetworkManager manager;
         while ((manager = this.pending.poll()) != null) {
             this.h.add(manager);
+            manager.isPending = false;
         }
     }
     // Paper end - prevent blocking on adding a new connection while the server is ticking
@@ -103,6 +105,7 @@ public class ServerConnection {
                         ;
                     }
 
+                    if (!disableFlushConsolidation) channel.pipeline().addFirst(new io.netty.handler.flush.FlushConsolidationHandler()); // Paper - Optimize network
                     // SportPaper start - new lines
                     channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30))
                             .addLast("legacy_query", new LegacyPingHandler(ServerConnection.this))
-- 
2.52.0

